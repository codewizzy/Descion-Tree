# -*- coding: utf-8 -*-
"""IIT2018085

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14u5zVoDgn8hUpBEskhX-SBWGForAhCOT
"""

import pandas as pd
import numpy as np
deciesp = np.finfo(float).eps

from numpy import log2 as log

ImportFromText = pd.read_csv('decdata.txt',sep=',',names=['buying','maint','doors','persons','lugboot','safety','Label'])

dataFrame = pd.DataFrame(ImportFromText)

def EntropyAttributeCalculator(dataFrame,Feature):

    cls = dataFrame.keys()[-1]
    uL = dataFrame[cls].unique()
    uAV = dataFrame[Feature].unique()
    EntFeature = 0
    for val in uAV:
        IndividualEntr = 0
        totalAttributes = len(dataFrame[Feature][dataFrame[Feature] == val])
        for predictedLabel in uL:
                NewDataLength = len(dataFrame[Feature][dataFrame[Feature]==val][dataFrame[cls] ==predictedLabel])
                IndividualEntr += -(NewDataLength/(totalAttributes+deciesp))*log((NewDataLength/(totalAttributes+deciesp))+deciesp)
        EntFeature += -(totalAttributes/len(dataFrame))*IndividualEntr
    return abs(EntFeature)


def displayTree(Tree):
    import pprint
    pprint.pprint(Tree)
    print()
    print()
    print()

def predictClass(Tree,tTest):
    predictedLabel = 0
    for dictKey in Tree.keys():
        val = tTest[dictKey]
        Tree = Tree[dictKey][val]
        predictedLabel = 0
        if type(Tree) is dict:
            predictedLabel = predictClass(Tree,tTest)
        else:
            predictedLabel = Tree
            break
    return predictedLabel

def modifiedTable(dataFrame, feat, category):
    return dataFrame[dataFrame[feat] == category].reset_index(drop=True)

def BestSplitTree(dataFrame):

    TotalGains = []
    for dictKey in dataFrame.keys()[:-1]:

         Classes = dataFrame.keys()[-1]
         IndividualEntr = 0
         uL = dataFrame[Classes].unique()
         for predictedLabel in uL:
             IndividualEntr += -(dataFrame[Classes].value_counts()[predictedLabel] / len(dataFrame[Classes])) * np.log2(dataFrame[Classes].value_counts()[predictedLabel] / len(dataFrame[Classes]))

         AttEntr = EntropyAttributeCalculator(dataFrame,dictKey)
         TotalGains.append(IndividualEntr-AttEntr)
    return dataFrame.keys()[:-1][np.argmax(TotalGains)]

def CheckModel(Tree,index):
    totalPoints = len(index)

    predictedCorrect = 0

    for i in index:
        t = dataFrame.iloc[i]
        correctClass = t['Label']
        test = t[:-1]
        test1 = pd.Series(dict(test))
        predictedCorrect+=(predictClass(Tree,test1)==correctClass)
    # print(predictedCorrect)

    acc = predictedCorrect/(totalPoints+deciesp)
    print("Model Accuracy = ",acc)


def GrowTreeRecursively(dataFrame, Tree=None):

    cls = dataFrame.keys()[-1]
    feat = BestSplitTree(dataFrame)
    featureValues = np.unique(dataFrame[feat])

    if Tree is None:
        Tree = {}
        Tree[feat] = {}

    for category in featureValues:

        Transformed_Table = modifiedTable(dataFrame, feat, category)

        ResultingC, nc = np.unique(Transformed_Table['Label'], return_counts=True)

        if len(nc) == 1:
            Tree[feat][category] = ResultingC[0]
        else:
            Tree[feat][category] = GrowTreeRecursively(Transformed_Table)

    return Tree


Tree = GrowTreeRecursively(dataFrame)
displayTree(Tree)

import random
index = []
for i in range(1,987):
    index.append(random.randint(0,len(dataFrame)-4))
CheckModel(Tree,index)